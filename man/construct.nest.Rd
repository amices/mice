% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nest.R
\name{construct.nest}
\alias{construct.nest}
\title{Construct blocks from \code{formulas} and \code{predictorMatrix}}
\usage{
construct.nest(formulas = NULL, predictorMatrix = NULL)
}
\arguments{
\item{formulas}{A named list with \eqn{q} component, each containing
one formula. The left hand side (LHS) specifies the
variables to be imputed, and the right hand side (RHS)
specifies the predictors used for imputation. For example,
model \code{y1 + y2 ~ x1 + x2} imputes \code{y1} and \code{y2} using \code{x1}
and \code{x2} as predictors. Imputation by a multivariate
imputation model imputes \code{y1} and \code{y2} simultaneously
by a joint model, whereas \code{mice()} can also impute
\code{y1} and \code{y2} by a repeated univariate model as
\code{y1 ~ y2 + x1 + x2} and \code{y2 ~ y1 + x1 + x2}.
The \code{formulas} argument is an alternative to the
combination of the \code{predictorMatrix} and
\code{blocks} arguments. It is more compact and allows for
more flexibility in specifying imputation models,
e.g., for adding
interaction terms (\code{y1 + y2 ~ x1 * x2} ),
logical variables (\code{y1 + y2 ~ x1 + (x2 > 20)}),
three-level categories (\code{y1 + y2 ~ x1 + cut(age, 3)}),
polytomous terms (\code{y1 + y2 ~ x1 + poly(age, 3)},
smoothing terms (\code{y1 + y2 ~ x1 + bs(age)}),
sum scores (\code{y1 + y2 ~ I(x1 + x2)}) or
quotients (\code{y1 + y2 ~ I(x1 / x2)})
on the fly.
Optionally, the user can name formulas. If not named,
\code{mice()} will name formulas with multiple variables
as \code{F1}, \code{F2}, and so on. Formulas with one
dependent (e.g. \code{ses ~ x1 + x2}) will be named
after the dependent variable \code{"ses"}.}

\item{predictorMatrix}{A square numeric matrix of maximal \eqn{p} rows and
maximal \eqn{p} columns. Row- and column names are
\code{colnames(data)}.
Each row corresponds to a variable to be imputed.
A value of \code{1} means that the column variable is a
predictor for the row variable, while a \code{0} means that
the column variable is not a predictor. The default
\code{predictorMatrix} is \code{1} everywhere, except for a zero
diagonal. Row- and column-names are optional for the
maximum \eqn{p} by \eqn{p} size. The user may specify a
smaller \code{predictorMatrix}, but column and row names are
then mandatory and should match be part of \code{colnames(data)}.
For variables that are not imputed, \code{mice()} automatically
sets the corresponding rows in the \code{predictorMatrix} to
zero. See details on \emph{skipping imputation}.
Two-level imputation models (which have \code{"2l"} in their
names) support other codes than \code{0} and \code{1}, e.g, \code{2}
or \code{-2} that assign special roles to some variables.}
}
\value{
A \code{blocks} object.
}
\description{
This helper function attempts to find blocks of variables in the
specification of the \code{formulas} and/or \code{predictorMatrix}
objects. Blocks specified by \code{formulas} may consist of
multiple variables. Blocks specified by \code{predictorMatrix} are
assumed to consist of single variables. Any duplicates in names are
removed, and the formula specification is preferred.
\code{predictorMatrix} and \code{formulas}. When both arguments
specify models for the same block, the model for the
\code{predictMatrix} is removed, and priority is given to the
specification given in \code{formulas}.
}
\examples{
form <- list(bmi + hyp ~ chl + age, chl ~ bmi)
pred <- make.predictorMatrix(nhanes[, c("age", "chl")])
construct.blocks(formulas = form, pred = pred)
}
\seealso{
\code{\link[=make.blocks]{make.blocks()}}, \code{\link[=name.blocks]{name.blocks()}}
}
