---
title: "Multivariate Amputation using Ampute"
author: "Rianne Schouten"
date: "Saturday, October 8th, 2016"
output: html_document
header-includes:
- \usepackage{blkarray}
- \usepackage{tikz}
- \usetikzlibrary{shapes,arrows}
- \usepackage{caption}
- \usepackage{graphicx}
- \usepackage{subcaption}
---

### Part 1

When new multiple imputation techniques are tested, simulated data sets have to be made incomplete. Often, a univariate amputation procedure is followed, generating missing values one variable at a time. This procedure is repeated for every variable that should have missing values and Van Buuren (2012, pp. 63, 64) explains in detail how this can be done. However, there are a few drawbacks of this method. First, a univariate approach makes it difficult to relate the missingness on one variable to the missingness on any other variable. Second, both simulated and real data have a multivariate structure. Applying a univeriate amputation procedure to multivariate data would not do justice to the complicated nature of data sets. Multivariate amputation is even more important because the multiple imputation is performed multivariately. For all these reasons, the function `ampute` is created to perform multivariate amputation according the user's desires. 

```{r, include = FALSE}
# Load packages
require("MASS")
require("mice")
require("lattice")
require("gridExtra")

# Underlying functions
source("../R/ampute.mcar.R")
source("../R/ampute.continuous.R")
source("../R/ampute.discrete.R")
source("../R/ampute.default.R")
source("../R/is.R")
source("../R/print.R")
source("../R/summary.R")
source("../R/bwplot.mads.R")
source("../R/xyplot.mads.R")
source("../R/mads.R")
source("../R/mdc.R")
source("../R/supports.transparent.R")

# Main function
source("../R/ampute.R")

set.seed(2016)
```

![Figure 1. Step-by-step flowchart of R-function ampute](Flowchart.jpg)

Function `ampute` has multiple options that can be specified. Figure \ref{fig1} gives an overview of all the possiblities and also in which order the decisions need to be taken. If a MCAR missingness mechanism is desired, for example, steps 6 to 9 do not need to be specified. 

The underlying method of `ampute` is based on Brand's (1999) multivariate amputation procedure. An adaptation to this method is made to make continuous amputation possible. The possibility to create MNAR missingness is an extra feature as well. Nevertheless, Figure \ref{fig1} not only shows the arguments of `ampute`, it also functions as a guideline in understanding the underlying procedure of multivariate amputation.

This vignette will discuss the multivariate amputation procedure with these same steps.

### 1. Data and quick amputation

First, a complete data set should be at hand. One could easily simulate such a data set using `mvrnorm()` from the package `MASS`. Be aware that the covariance matrix should be semi definite. 

```{r}
testdata <- mvrnorm(n = 10000, mu = c(10, 5, 0), 
                    Sigma = matrix(data = c(1.0, 0.2, 0.2, 0.2, 1.0, 0.2, 
                                            0.2, 0.2, 1.0), nrow = 3, byrow = T))
testdata <- as.data.frame(testdata)
summary(testdata)
```

The function `ampute` immediately works when the data are entered into the function. Storing the result allows you to work with the amputed data. 

```{r}
result <- ampute(testdata)
result
```

#### Class

The return object is of class `mads` (Multivariately Amputed Data Set) and contains all the useful information about the amputation. In total, the object contains the following:

```{r}
names(result)
```

#### Inspect amputed data

The amputed data is stored under `amp`. To see whether the amputation has gone according plan, a quick investigation can be done by using function `md.pattern`.

```{r}
md.pattern(result$amp)
```

The rows of the table show the different missing data patterns with the number of cases accordingly. The first row always refers to the complete cases. The last column contains the number of variables with missings in that specific pattern. Consequently, the values at the end of each column are the total number of cells that are missing for that variable. A more thorough explanation of the function can be found in the help file (`?md.pattern`). Note that because `md.pattern` sorts the columns in increasing amounts of missing information, the order of the variables is different from the order in the data. 

### 2. Proportion of missingness

The proportion of missingness is specified under:

```{r}
result$prop
```

In the default setting, this means that 50% of the cases will have missing values. It is easy to change this proportion by using the argument `prop`. One might also want to specify the percentage of missing cells. For this, the argument `bycases` should be `FALSE`. 

```{r}
result <- ampute(testdata, prop = 0.2, bycases = FALSE)
md.pattern(result$amp)
``` 

An inspection of the result shows that the proportion of missing cells is approximately 20%, as requested (the data set contains 10000 * 3 = 30000 cells, in total, 5975 cells are made missing). `ampute` automatically calculates the proportion of missing cases that belongs to this setting. 

```{r}
result$prop
```

### 3. Patterns

The basic idea of `ampute` is the creation of missingness patterns. Each pattern is a combination of missingness on specific variables while other variables remain complete. For example, someone could have forgotten the last page of a questionnaire, resulting in missingness on a specific set of questions. Another missingness pattern could occur when someone is not willing to answer private questions. Or when a participant misses a wave in a longitudinal study. Consequently, each pattern is a specific combination of missing and complete variables. 

The default missingness patterns can by obtained by:  

```{r}
mypatterns <- result$patterns
mypatterns
```

In the `patterns` matrix, each row refers to a missing data pattern and each column to a variable. `0` is used for variables that should have missing values in a particular pattern. `1` is used otherwise. Here, three missing data patterns are specified with missing values on 1 variable only. Note that as a result of this, none of the cases will have missingness on more than one variable. A case either has missingness on V1, V2 or V3 or remains complete.  

Subsequently, the default `patterns` matrix can be changed according your desires. For example, the missingness patterns might be changed into:

```{r}
mypatterns[2, 1] <- 0
mypatterns <- rbind(mypatterns, c(0, 1, 0))
mypatterns
```

By doing this, a missingness pattern is created where cases will have missingness on V1 and V2 but not on V3 (pattern 2). Also, I have added a fourth missing data pattern to create a combinaton of missingness on V1 and V3. 

Now, I can ampute the data again, with the desired `patterns` matrix as its third argument. Note that I have changed the desired proportion of missingness to `bycases = TRUE` (default) and 30%. 

```{r}
result <- ampute(testdata, prop = 0.3, patterns = mypatterns)
md.pattern(result$amp)
```

### 4. Relative frequency

The function `ampute` works by assigning cases to the different missing data patterns. Each case is assigned to one pattern only, and all cases are divided among the patterns. In other words, every case is \textit{candidate} for a certain missing data pattern. This does not automatically mean that each case will obtain missing values. That decision will be made later on. 

The argument `freq` specifies with which frequency the cases should be divided over the patterns. As a default, equal frequencies are used for the patterns.  

```{r}
result$freq
```

The specifications below are an example of a situation where one wants to impose missing data pattern 1 with a higher frequency than the other missing data patterns. When changing the `freq` argument, one should keep in mind that the sum of the relative frequencies should be 1 (in order to divide all the cases over the patterns). 

```{r}
result <- ampute(testdata, prop = 0.3, patterns = mypatterns, 
                 freq = c(0.7, 0.1, 0.1, 0.1))
md.pattern(result$amp)
```

An inspection of the missingness patterns using `md.pattern` shows that indeed pattern 1 has received 7 times as many candidates as pattern 2 to 4. In total, approximately 3000 cases have missing values (which is what was specified). 

### 5. Mechanism

At this point, the total proportion of missingness is defined, the missing data patterns are specified as well as the relative frequency with which they should occur. All cases are candidate for a missing data pattern. 

Whether a case will be made missing eventually, depends on the missingness mechanism. If each case should have an equal probability of having missing values, the argument `mech` should be changed to `"MCAR"` (Missing Completely At Random). Then, step 6 to 9 do not need to be specified. 

```{r}
result <- ampute(testdata, prop = 0.3, patterns = mypatterns, 
                 freq = c(0.7, 0.1, 0.1, 0.1), mech = "MCAR")
result$mech
```

Two other opties are `"MAR"` (Missing At Random), where the probability to be missing depends on the values of the variables that will not be made missing (the 'observed' variables) or `"MNAR"` (Missing Not At Random), where these probabilities depend on the values of the variables that will be made missing. For a more thorough explanation of these terms, Van Buuren (2012, pp. 6, 7, 31, 32) is useful. 

### 6. Weights

In case of `MAR` (default) or `MNAR` missingness, a weighted sum score will be calculated for each case. This is an important part in the process because the probability that a case will be made missing, depends on this score. In what way the sum scores are used, will be explained in step 8 and step 9. 

The weighted sum scores are built from the variable values and certain pre-specified weights. For each case, the value on a certain variable is multiplied with a weight. This is done for all variables and the resulting values are summed: a weighted sum score. The formula that describes the calculation is: 

\begin{equation}
c_{ik} = \sum\limits_{j=1}^J w_{jk}*c_{ij}
\end{equation}

where $c_{ik}$ is a case $i$ in a certain pattern $k$, $w_{jk}$ is the pre-specified weight of a certain variable $j$ in a certain pattern $k$ and $c_{ij}$ is the value of case $i$ on variable $j$. In the example, $j\in\{1, 2, 3\}$ and $k\in\{1, 2, 3, 4\}$ because there are three variables and four missing data patterns. 

The `weights` matrix stores the $w_{jk}$ and is of size #patterns by #variables. The default `weights` matrix for `MAR` missingness is as follows. 

```{r}
result <- ampute(testdata, prop = 0.3, patterns = mypatterns, 
                 freq = c(0.7, 0.1, 0.1, 0.1))
myweights <- result$weights
myweights
```

At first sight, this matrix might be complicated, but if you compare the matrix with the `patterns` matrix that was used, the contents make more sense. 

```{r}
mypatterns
```

As you see, the matrices are exactly similar. The reason for this is that in case of `MAR` missingness, the variables that will be made missing should not be weighted (`0` in the `weights` matrix). Those are the variables with `0` in the `patterns` matrix. As a default, the other variables are equally weighted. 

In case of `MNAR` missingness, the default `weights` matrix is as follows:

```{r}
result <- ampute(testdata, prop = 0.3, patterns = mypatterns, 
                 freq = c(0.7, 0.1, 0.1, 0.1), mech = "MNAR")
result$weights
```

If this matrix is compared with the `patterns` matrix that was used, it is easy to see that the values are reversed. Because in a `MNAR` missingness mechanism, especially the variables that are made missing are of importance, those variables are weighted. Here, they have received equal weights of `1`. The variables that will remain complete are not weighted and receive a `0`.  

Naturally, the idea of the `weights` matrix is to weight variables differently from each other. From now on, we will impose a `MAR` mechanism to the data. We therefore focus at the default `weights` matrix which we stored under `myweights`. 

For instance, we could desire to weight the values on variable V2 heavier than the values on variable V3. For pattern 1, we could change the `weights` matrix into something as: 

```{r}
myweights[1, ] <- c(0, 0.8, 0.4)
```

By choosing the values 0.8 and 0.4, variable V2 is weighted twice as heavy as variable V3. The values are relative values, meaning that choosing the values 8 and 4 would have the same effect on the amputation process. In order to clearly see the result of the `weights` setting, one can specify weights for just a few variables and with a relative big distance from each other. 

For pattern 3, variable V1 will be weighted three times as heavy as variable V2. 

```{r}
myweights[3, ] <- c(3, 1, 0)
myweights
```

We will now apply these settings and inspect the results in two ways: boxplots and scatterplots.   

```{r}
result <- ampute(testdata, prop = 0.3, patterns = mypatterns, 
                 freq = c(0.7, 0.1, 0.1, 0.1), weights = myweights)
```

#### Boxplots

First, there is the function `bwplot` that can be imposed on the `mads` object immediately. `bwplot` plots the distributions of the amputed and non-amputed data for several variables. This is useful, because these boxplots show the relation between the missingness and the variables values. In other words, by examining the boxplots one can see for which values of a certain variable the data will be amputed. Note that not necessarily the values of the variables themselves will be amputed. The boxplots merely show the relation between the amputations and the variables. 

In the function `bwplot`, the argument `which.pat` can be used to define the patterns you are interested in (default: all patterns). The argument `yvar` should contain the variables names (default: all variables). Besides, the function returns the mean, variance and n of the amputed and non-amputed data for each variable and each pattern requested. In the column `Amp`, a `1` refers to the amputed data and `0` to the non-amputed data. If the descriptives are not required, the argument `descriptives` can be set to `FALSE`. 

```{r}
bwplot(result, which.pat = c(1, 3))
```

The medians and boundaries of the boxes show that in pattern 1, the amputed data is shifted to the right with respect to the non-amputed data. For variable V2, this effect is the biggest, due to the weight value that was specified. For V1, there is a very small difference between the boxplots of the amputed and non-amputed data. This makes sense, because variable V1 was amputed in the first pattern and therefore set to `0` in the `weights` matrix. The small difference that is visible is due to the positive correlation between V1 on the one side and V2 and V3 on the other side. These correlations were created during the simulation of the data. 

If desired, one could use the function `tsum.test` from package `BSDA` to perform a t-test on the amputed and non-amputed data. The data returned in the descriptives table can be used for that. For example, to know whether the mean difference between the amputed and non-amputed data for variable V2 in pattern 1 is significant, one could run:

```{r, include = FALSE}
require(BSDA)
```

```{r}
tsum.test(mean.x = 0.52490, mean.y = -0.23120,
          s.x = sqrt(0.85914), s.y = sqrt(0.89365),
          n.x = 2119, n.y = 4876)
```

As is visible, there is a significant difference between the amputed and non-amputed data of variable V2 in pattern 1. 

For pattern 3, the difference between the distributions of the amputed and non-amputed data is biggest for variable V1, as is expected due to the weights values in pattern 3. 


#### Scatterplots

Scatterplots might also help to investigate the effect of the specifications. The function `xyplot` can be directly imposed on the `mads` object and contains arguments comparable to `bwplot`. For example, the weighted sum scores of pattern 1 can be set against the three variables. 

```{r}
xyplot(result, which.pat = 1)
```

The scatterplots show that there is a very small relation between V1 and the weighted sum scores. Furthermore, the relation between V2 and the weighted sum scores is very strong, meaning that a case's value on V2 is very important in the creation of the weighted sum score. Actually, this is what causes the differences between the amputed and non-amputed data in the boxplots above. For V3 and the weighted sum scores, the relation is a bit weaker than for V2 but more present than for V1. 

### References

Brand, J.P.L. (1999). \emph{Development, implementation and 
evaluation of multiple imputation strategies for the statistical analysis of incomplete data sets} (pp. 110-113). Dissertation. Rotterdam: Erasmus University.

Van Buuren, S. (2012). \emph{Flexible imputation of missing data.}
Boca Raton, FL.: Chapman & Hall/CRC Press.

Vink, G. (2016). Towards a standardized evaluation of multiple imputation routines. Unpublished article. 
